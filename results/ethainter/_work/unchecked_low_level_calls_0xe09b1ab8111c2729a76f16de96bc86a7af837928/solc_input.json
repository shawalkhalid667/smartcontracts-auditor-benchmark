{"language": "Solidity", "sources": {"unchecked_low_level_calls_0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol": {"content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 150\n */\n\npragma solidity ^0.4.24;\n\n/* This is fiftyflip \na simple yet elegant game contract \nthat is connected to Proof of Community \ncontract(0x1739e311ddBf1efdFbc39b74526Fd8b600755ADa).\n\nGreed serves no-one but the one, \nBut charity is kind, suffereth not and envieth not. \nCharity is to give of oneself in the service of his fellow beings. \n\nPlay on Players. and Remember fifty feeds the multiudes and gives to the PoC community\nForever and ever. \n\n\n*/\n\n\ncontract FiftyFlip {\n    uint constant DONATING_X = 20; // 2% kujira\n\n    // Need to be discussed\n    uint constant JACKPOT_FEE = 10; // 1% jackpot\n    uint constant JACKPOT_MODULO = 1000; // 0.1% jackpotwin\n    uint constant DEV_FEE = 20; // 2% devfee\n    uint constant WIN_X = 1900; // 1.9x\n\n    // There is minimum and maximum bets.\n    uint constant MIN_BET = 0.01 ether;\n    uint constant MAX_BET = 1 ether;\n\n    uint constant BET_EXPIRATION_BLOCKS = 250;\n\n    // owner and PoC contract address\n    address public owner;\n    address public autoPlayBot;\n    address public secretSigner;\n    address private whale;\n\n    // Accumulated jackpot fund.\n    uint256 public jackpotSize;\n    uint256 public devFeeSize;\n\n    // Funds that are locked in potentially winning bets.\n    uint256 public lockedInBets;\n    uint256 public totalAmountToWhale;\n\n\n    struct Bet {\n        // Wager amount in wei.\n        uint amount;\n        // Block number of placeBet tx.\n        uint256 blockNumber;\n        // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\n        bool betMask;\n        // Address of a player, used to pay out winning bets.\n        address player;\n    }\n\n    mapping (uint => Bet) bets;\n    mapping (address => uint) donateAmount;\n\n    // events\n    event Wager(uint ticketID, uint betAmount, uint256 betBlockNumber, bool betMask, address betPlayer);\n    event Win(address winner, uint amount, uint ticketID, bool maskRes, uint jackpotRes);\n    event Lose(address loser, uint amount, uint ticketID, bool maskRes, uint jackpotRes);\n    event Refund(uint ticketID, uint256 amount, address requester);\n    event Donate(uint256 amount, address donator);\n    event FailedPayment(address paidUser, uint amount);\n    event Payment(address noPaidUser, uint amount);\n    event JackpotPayment(address player, uint ticketID, uint jackpotWin);\n\n    // constructor\n    constructor (address whaleAddress, address autoPlayBotAddress, address secretSignerAddress) public {\n        owner = msg.sender;\n        autoPlayBot = autoPlayBotAddress;\n        whale = whaleAddress;\n        secretSigner = secretSignerAddress;\n        jackpotSize = 0;\n        devFeeSize = 0;\n        lockedInBets = 0;\n        totalAmountToWhale = 0;\n    }\n\n    // modifiers\n    modifier onlyOwner() {\n        require (msg.sender == owner, \"You are not the owner of this contract!\");\n        _;\n    }    \n\n    modifier onlyBot() {\n        require (msg.sender == autoPlayBot, \"You are not the bot of this contract!\");\n        _;\n    }\n    \n    modifier checkContractHealth() {\n        require (address(this).balance >= lockedInBets + jackpotSize + devFeeSize, \"This contract doesn't have enough balance, it is stopped till someone donate to this game!\");\n        _;\n    }\n\n    // betMast:\n    // false is front, true is back\n\n    function() public payable { }\n\n\n    function setBotAddress(address autoPlayBotAddress)\n    onlyOwner() \n    external \n    {\n        autoPlayBot = autoPlayBotAddress;\n    }\n\n    function setSecretSigner(address _secretSigner)\n    onlyOwner()  \n    external\n    {\n        secretSigner = _secretSigner;\n    }\n\n    // wager function\n    function wager(bool bMask, uint ticketID, uint ticketLastBlock, uint8 v, bytes32 r, bytes32 s)  \n    checkContractHealth()\n    external\n    payable { \n        Bet storage bet = bets[ticketID];\n        uint amount = msg.value;\n        address player = msg.sender;\n        require (bet.player == address(0), \"Ticket is not new one!\");\n        require (amount >= MIN_BET, \"Your bet is lower than minimum bet amount\");\n        require (amount <= MAX_BET, \"Your bet is higher than maximum bet amount\");\n        require (getCollateralBalance() >= 2 * amount, \"If we accept this, this contract will be in danger!\");\n\n        require (block.number <= ticketLastBlock, \"Ticket has expired.\");\n        bytes32 signatureHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n37', uint40(ticketLastBlock), ticketID));\n        require (secretSigner == ecrecover(signatureHash, v, r, s), \"web3 vrs signature is not valid.\");\n\n        jackpotSize += amount * JACKPOT_FEE / 1000;\n        devFeeSize += amount * DEV_FEE / 1000;\n        lockedInBets += amount * WIN_X / 1000;\n\n        uint donate_amount = amount * DONATING_X / 1000;\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(donate_amount)(bytes4(keccak256(\"donate()\")));\n        totalAmountToWhale += donate_amount;\n\n        bet.amount = amount;\n        bet.blockNumber = block.number;\n        bet.betMask = bMask;\n        bet.player = player;\n\n        emit Wager(ticketID, bet.amount, bet.blockNumber, bet.betMask, bet.player);\n    }\n\n    // method to determine winners and losers\n    function play(uint ticketReveal)\n    checkContractHealth()\n    external\n    {\n        uint ticketID = uint(keccak256(abi.encodePacked(ticketReveal)));\n        Bet storage bet = bets[ticketID];\n        require (bet.player != address(0), \"TicketID is not correct!\");\n        require (bet.amount != 0, \"Ticket is already used one!\");\n        uint256 blockNumber = bet.blockNumber;\n        if(blockNumber < block.number && blockNumber >= block.number - BET_EXPIRATION_BLOCKS)\n        {\n            uint256 random = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  ticketReveal)));\n            bool maskRes = (random % 2) !=0;\n            uint jackpotRes = random % JACKPOT_MODULO;\n    \n            uint tossWinAmount = bet.amount * WIN_X / 1000;\n\n            uint tossWin = 0;\n            uint jackpotWin = 0;\n            \n            if(bet.betMask == maskRes) {\n                tossWin = tossWinAmount;\n            }\n            if(jackpotRes == 0) {\n                jackpotWin = jackpotSize;\n                jackpotSize = 0;\n            }\n            if (jackpotWin > 0) {\n                emit JackpotPayment(bet.player, ticketID, jackpotWin);\n            }\n            if(tossWin + jackpotWin > 0)\n            {\n                payout(bet.player, tossWin + jackpotWin, ticketID, maskRes, jackpotRes);\n            }\n            else \n            {\n                loseWager(bet.player, bet.amount, ticketID, maskRes, jackpotRes);\n            }\n            lockedInBets -= tossWinAmount;\n            bet.amount = 0;\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function donateForContractHealth()\n    external \n    payable\n    {\n        donateAmount[msg.sender] += msg.value;\n        emit Donate(msg.value, msg.sender);\n    }\n\n    function withdrawDonation(uint amount)\n    external \n    {\n        require(donateAmount[msg.sender] >= amount, \"You are going to withdraw more than you donated!\");\n        \n        if (sendFunds(msg.sender, amount)){\n            donateAmount[msg.sender] -= amount;\n        }\n    }\n\n    // method to refund\n    function refund(uint ticketID)\n    checkContractHealth()\n    external {\n        Bet storage bet = bets[ticketID];\n        \n        require (bet.amount != 0, \"this ticket has no balance\");\n        require (block.number > bet.blockNumber + BET_EXPIRATION_BLOCKS, \"this ticket is expired.\");\n        sendRefund(ticketID);\n    }\n\n    // Funds withdrawl\n    function withdrawDevFee(address withdrawAddress, uint withdrawAmount)\n    onlyOwner()\n    checkContractHealth() \n    external {\n        require (devFeeSize >= withdrawAmount, \"You are trying to withdraw more amount than developer fee.\");\n        require (withdrawAmount <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (devFeeSize <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (sendFunds(withdrawAddress, withdrawAmount)){\n            devFeeSize -= withdrawAmount;\n        }\n    }\n\n    // Funds withdrawl\n    function withdrawBotFee(uint withdrawAmount)\n    onlyBot()\n    checkContractHealth() \n    external {\n        require (devFeeSize >= withdrawAmount, \"You are trying to withdraw more amount than developer fee.\");\n        require (withdrawAmount <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (devFeeSize <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (sendFunds(autoPlayBot, withdrawAmount)){\n            devFeeSize -= withdrawAmount;\n        }\n    }\n\n    // Get Bet Info from id\n    function getBetInfo(uint ticketID) \n    constant\n    external \n    returns (uint, uint256, bool, address){\n        Bet storage bet = bets[ticketID];\n        return (bet.amount, bet.blockNumber, bet.betMask, bet.player);\n    }\n\n    // Get Bet Info from id\n    function getContractBalance() \n    constant\n    external \n    returns (uint){\n        return address(this).balance;\n    }\n\n    // Get Collateral for Bet\n    function getCollateralBalance() \n    constant\n    public \n    returns (uint){\n        if (address(this).balance > lockedInBets + jackpotSize + devFeeSize)\n            return address(this).balance - lockedInBets - jackpotSize - devFeeSize;\n        return 0;\n    }\n\n    // Contract may be destroyed only when there are no ongoing bets,\n    // either settled or refunded. All funds are transferred to contract owner.\n    function kill() external onlyOwner() {\n        require (lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\n        selfdestruct(owner);\n    }\n\n    // Payout ETH to winner\n    function payout(address winner, uint ethToTransfer, uint ticketID, bool maskRes, uint jackpotRes) \n    internal \n    {        \n        winner.transfer(ethToTransfer);\n        emit Win(winner, ethToTransfer, ticketID, maskRes, jackpotRes);\n    }\n\n    // sendRefund to requester\n    function sendRefund(uint ticketID) \n    internal \n    {\n        Bet storage bet = bets[ticketID];\n        address requester = bet.player;\n        uint256 ethToTransfer = bet.amount;        \n        requester.transfer(ethToTransfer);\n\n        uint tossWinAmount = bet.amount * WIN_X / 1000;\n        lockedInBets -= tossWinAmount;\n\n        bet.amount = 0;\n        emit Refund(ticketID, ethToTransfer, requester);\n    }\n\n    // Helper routine to process the payment.\n    function sendFunds(address paidUser, uint amount) private returns (bool){\n        bool success = paidUser.send(amount);\n        if (success) {\n            emit Payment(paidUser, amount);\n        } else {\n            emit FailedPayment(paidUser, amount);\n        }\n        return success;\n    }\n    // Payout ETH to whale when player loses\n    function loseWager(address player, uint amount, uint ticketID, bool maskRes, uint jackpotRes) \n    internal \n    {\n        emit Lose(player, amount, ticketID, maskRes, jackpotRes);\n    }\n\n    // bulk clean the storage.\n    function clearStorage(uint[] toCleanTicketIDs) external {\n        uint length = toCleanTicketIDs.length;\n\n        for (uint i = 0; i < length; i++) {\n            clearProcessedBet(toCleanTicketIDs[i]);\n        }\n    }\n\n    // Helper routine to move 'processed' bets into 'clean' state.\n    function clearProcessedBet(uint ticketID) private {\n        Bet storage bet = bets[ticketID];\n\n        // Do not overwrite active bets with zeros; additionally prevent cleanup of bets\n        // for which ticketID signatures may have not expired yet (see whitepaper for details).\n        if (bet.amount != 0 || block.number <= bet.blockNumber + BET_EXPIRATION_BLOCKS) {\n            return;\n        }\n\n        bet.blockNumber = 0;\n        bet.betMask = false;\n        bet.player = address(0);\n    }\n\n    // A trap door for when someone sends tokens other than the intended ones so the overseers can decide where to send them.\n    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) \n    public \n    onlyOwner() \n    returns (bool success) \n    {\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface \n{\n    function transfer(address to, uint256 tokens) public returns (bool success);\n}"}}, "settings": {"optimizer": {"enabled": false}, "outputSelection": {"*": {"*": ["evm.bytecode.object"]}}}}