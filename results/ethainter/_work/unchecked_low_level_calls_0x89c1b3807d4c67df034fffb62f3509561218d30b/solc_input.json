{"language": "Solidity", "sources": {"unchecked_low_level_calls_0x89c1b3807d4c67df034fffb62f3509561218d30b.sol": {"content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 162,175,180,192\n */\n\npragma solidity ^0.4.9;\n\ncontract TownCrier {\n    struct Request { // the data structure for each request\n        address requester; // the address of the requester\n        uint fee; // the amount of wei the requester pays for the request\n        address callbackAddr; // the address of the contract to call for delivering response\n        bytes4 callbackFID; // the specification of the callback function\n        bytes32 paramsHash; // the hash of the request parameters\n    }\n   \n    event Upgrade(address newAddr);\n    event Reset(uint gas_price, uint min_fee, uint cancellation_fee); \n    event RequestInfo(uint64 id, uint8 requestType, address requester, uint fee, address callbackAddr, bytes32 paramsHash, uint timestamp, bytes32[] requestData); // log of requests, the Town Crier server watches this event and processes requests\n    event DeliverInfo(uint64 requestId, uint fee, uint gasPrice, uint gasLeft, uint callbackGas, bytes32 paramsHash, uint64 error, bytes32 respData); // log of responses\n    event Cancel(uint64 requestId, address canceller, address requester, uint fee, int flag); // log of cancellations\n\n    address public constant SGX_ADDRESS = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593;// address of the SGX account\n\n    uint public GAS_PRICE = 5 * 10**10;\n    uint public MIN_FEE = 30000 * GAS_PRICE; // minimum fee required for the requester to pay such that SGX could call deliver() to send a response\n    uint public CANCELLATION_FEE = 25000 * GAS_PRICE; // charged when the requester cancels a request that is not responded\n\n    uint public constant CANCELLED_FEE_FLAG = 1;\n    uint public constant DELIVERED_FEE_FLAG = 0;\n    int public constant FAIL_FLAG = -2 ** 250;\n    int public constant SUCCESS_FLAG = 1;\n\n    bool public killswitch;\n\n    bool public externalCallFlag;\n\n    uint64 public requestCnt;\n    uint64 public unrespondedCnt;\n    Request[2**64] public requests;\n\n    int public newVersion = 0;\n\n    // Contracts that receive Ether but do not define a fallback function throw\n    // an exception, sending back the Ether (this was different before Solidity\n    // v0.4.0). So if you want your contract to receive Ether, you have to\n    // implement a fallback function.\n    function () {}\n\n    function TownCrier() public {\n        // Start request IDs at 1 for two reasons:\n        //   1. We can use 0 to denote an invalid request (ids are unsigned)\n        //   2. Storage is more expensive when changing something from zero to non-zero,\n        //      so this means the first request isn't randomly more expensive.\n        requestCnt = 1;\n        requests[0].requester = msg.sender;\n        killswitch = false;\n        unrespondedCnt = 0;\n        externalCallFlag = false;\n    }\n\n    function upgrade(address newAddr) {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            newVersion = -int(newAddr);\n            killswitch = true;\n            Upgrade(newAddr);\n        }\n    }\n\n    function reset(uint price, uint minGas, uint cancellationGas) public {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            GAS_PRICE = price;\n            MIN_FEE = price * minGas;\n            CANCELLATION_FEE = price * cancellationGas;\n            Reset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);\n        }\n    }\n\n    function suspend() public {\n        if (msg.sender == requests[0].requester) {\n            killswitch = true;\n        }\n    }\n\n    function restart() public {\n        if (msg.sender == requests[0].requester && newVersion == 0) {\n            killswitch = false;\n        }\n    }\n\n    function withdraw() public {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            if (!requests[0].requester.call.value(this.balance)()) {\n                throw;\n            }\n        }\n    }\n\n    function request(uint8 requestType, address callbackAddr, bytes4 callbackFID, uint timestamp, bytes32[] requestData) public payable returns (int) {\n        if (externalCallFlag) {\n            throw;\n        }\n\n        if (killswitch) {\n            externalCallFlag = true;\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            return newVersion;\n        }\n\n        if (msg.value < MIN_FEE) {\n            externalCallFlag = true;\n            // If the amount of ether sent by the requester is too little or \n            // too much, refund the requester and discard the request.\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            return FAIL_FLAG;\n        } else {\n            // Record the request.\n            uint64 requestId = requestCnt;\n            requestCnt++;\n            unrespondedCnt++;\n\n            bytes32 paramsHash = sha3(requestType, requestData);\n            requests[requestId].requester = msg.sender;\n            requests[requestId].fee = msg.value;\n            requests[requestId].callbackAddr = callbackAddr;\n            requests[requestId].callbackFID = callbackFID;\n            requests[requestId].paramsHash = paramsHash;\n\n            // Log the request for the Town Crier server to process.\n            RequestInfo(requestId, requestType, msg.sender, msg.value, callbackAddr, paramsHash, timestamp, requestData);\n            return requestId;\n        }\n    }\n\n    function deliver(uint64 requestId, bytes32 paramsHash, uint64 error, bytes32 respData) public {\n        if (msg.sender != SGX_ADDRESS ||\n                requestId <= 0 ||\n                requests[requestId].requester == 0 ||\n                requests[requestId].fee == DELIVERED_FEE_FLAG) {\n            // If the response is not delivered by the SGX account or the \n            // request has already been responded to, discard the response.\n            return;\n        }\n\n        uint fee = requests[requestId].fee;\n        if (requests[requestId].paramsHash != paramsHash) {\n            // If the hash of request parameters in the response is not \n            // correct, discard the response for security concern.\n            return;\n        } else if (fee == CANCELLED_FEE_FLAG) {\n            // If the request is cancelled by the requester, cancellation \n            // fee goes to the SGX account and set the request as having\n            // been responded to.\n            // <yes> <report> UNCHECKED_LL_CALLS\n            SGX_ADDRESS.send(CANCELLATION_FEE);\n            requests[requestId].fee = DELIVERED_FEE_FLAG;\n            unrespondedCnt--;\n            return;\n        }\n\n        requests[requestId].fee = DELIVERED_FEE_FLAG;\n        unrespondedCnt--;\n\n        if (error < 2) {\n            // Either no error occurs, or the requester sent an invalid query.\n            // Send the fee to the SGX account for its delivering.\n            // <yes> <report> UNCHECKED_LL_CALLS\n            SGX_ADDRESS.send(fee);         \n        } else {\n            // Error in TC, refund the requester.\n            externalCallFlag = true;\n            // <yes> <report> UNCHECKED_LL_CALLS\n            requests[requestId].requester.call.gas(2300).value(fee)();\n            externalCallFlag = false;\n        }\n\n        uint callbackGas = (fee - MIN_FEE) / tx.gasprice; // gas left for the callback function\n        DeliverInfo(requestId, fee, tx.gasprice, msg.gas, callbackGas, paramsHash, error, respData); // log the response information\n        if (callbackGas > msg.gas - 5000) {\n            callbackGas = msg.gas - 5000;\n        }\n        \n        externalCallFlag = true;\n        // <yes> <report> UNCHECKED_LL_CALLS\n        requests[requestId].callbackAddr.call.gas(callbackGas)(requests[requestId].callbackFID, requestId, error, respData); // call the callback function in the application contract\n        externalCallFlag = false;\n    }\n\n    function cancel(uint64 requestId) public returns (int) {\n        if (externalCallFlag) {\n            throw;\n        }\n\n        if (killswitch) {\n            return 0;\n        }\n\n        uint fee = requests[requestId].fee;\n        if (requests[requestId].requester == msg.sender && fee >= CANCELLATION_FEE) {\n            // If the request was sent by this user and has money left on it,\n            // then cancel it.\n            requests[requestId].fee = CANCELLED_FEE_FLAG;\n            externalCallFlag = true;\n            if (!msg.sender.call.value(fee - CANCELLATION_FEE)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            Cancel(requestId, msg.sender, requests[requestId].requester, requests[requestId].fee, 1);\n            return SUCCESS_FLAG;\n        } else {\n            Cancel(requestId, msg.sender, requests[requestId].requester, fee, -1);\n            return FAIL_FLAG;\n        }\n    }\n}"}}, "settings": {"optimizer": {"enabled": false}, "outputSelection": {"*": {"*": ["evm.bytecode.object"]}}}}