=== SYSTEM ===
You are a smart contract security auditor.

CRITICAL OUTPUT RULES:
- Output MUST be exactly ONE valid JSON object and NOTHING ELSE.
- The first character MUST be '{' and the last character MUST be '}'.
- Do NOT output prose, markdown, numbering, code fences, or extra commentary.

Task: Identify which SmartBugs vulnerability categories are present in the contract.

Allowed categories (use these exact strings):
unchecked_low_level_calls, time_manipulation, bad_randomness, denial_of_service, front_running,
access_control, short_addresses, reentrancy, arithmetic, other

Output JSON schema (exact keys):
{
  "findings": [
    {
      "category": "<one of the allowed categories>",
      "severity": <int 1..5>,
      "confidence": <int 1..3>,
      "title": "<short>",
      "rationale": "<1-3 sentences>"
    }
  ],
  "detected_categories": ["..."]
}

Rules:
- If you are not confident, omit the finding (prefer precision).
- If you find nothing, output {"findings": [], "detected_categories": []}.
- Do not include any text outside the JSON object.


=== USER ===
Return ONLY the JSON object described in the system message.
CONTRACT_FILE: access_control_wallet_03_wrong_constructor.sol
SOLIDITY_SOURCE_BEGIN
/*
 * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-105#wallet-03-wrong-constructorsol
 * @author: -
 * @vulnerable_at_lines: 19,20
 */

 pragma solidity ^0.4.24;

 /* User can add pay in and withdraw Ether.
    The constructor is wrongly named, so anyone can become 'creator' and withdraw all funds.
 */

 contract Wallet {
     address creator;

     mapping(address => uint256) balances;
     
     // <yes> <report> ACCESS_CONTROL
     function initWallet() public {
         creator = msg.sender;
     }

     function deposit() public payable {
         assert(balances[msg.sender] + msg.value > balances[msg.sender]);
         balances[msg.sender] += msg.value;
     }

     function withdraw(uint256 amount) public {
         require(amount <= balances[msg.sender]);
         msg.sender.transfer(amount);
         balances[msg.sender] -= amount;
     }

     // In an emergency the owner can migrate  allfunds to a different address.

     function migrateTo(address to) public {
         require(creator == msg.sender);
         to.transfer(this.balance);
     }

 }

SOLIDITY_SOURCE_END


=== MODEL_OUTPUT ===
0. The contract does not use call.value() or delegatecall(), which are common sources of vulnerabilities. There are no time constraints in critical operations that could be exploited. The access control mechanism is present but not properly implemented; the initWallet() function should be restricted to the creator only. The withdraw() function does not have a reentrancy guard, but since it uses msg.sender.transfer(), which is equivalent to call.value(), it would revert on failure, preventing reentrancy. The arithmetic operations are safe as they use uint256 which cannot go below zero. There is no use of block.timestamp or now, thus avoiding time manipulation vulnerabilities. The random number generation is not used in any critical operations, hence there is no concern for bad randomness affecting contract logic. Overall, the contract has some access control issues but is secure against other common vulnerabilities.

=== ERROR ===


=== ELAPSED_S ===
4.5451
