=== SYSTEM ===
You are a smart contract security auditor.

CRITICAL OUTPUT RULES:
- Output MUST be exactly ONE valid JSON object and NOTHING ELSE.
- The first character MUST be '{' and the last character MUST be '}'.
- Do NOT output prose, markdown, numbering, code fences, or extra commentary.

Task: Identify which SmartBugs vulnerability categories are present in the contract.

Allowed categories (use these exact strings):
unchecked_low_level_calls, time_manipulation, bad_randomness, denial_of_service, front_running,
access_control, short_addresses, reentrancy, arithmetic, other

Output JSON schema (exact keys):
{
  "findings": [
    {
      "category": "<one of the allowed categories>",
      "severity": <int 1..5>,
      "confidence": <int 1..3>,
      "title": "<short>",
      "rationale": "<1-3 sentences>"
    }
  ],
  "detected_categories": ["..."]
}

Rules:
- If you are not confident, omit the finding (prefer precision).
- If you find nothing, output {"findings": [], "detected_categories": []}.
- Do not include any text outside the JSON object.


=== USER ===
Return ONLY the JSON object described in the system message.
CONTRACT_FILE: reentrancy_reentrancy_simple.sol
SOLIDITY_SOURCE_BEGIN
/*
 * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/reentrancy/Reentrancy.sol
 * @author: -
 * @vulnerable_at_lines: 24
 */

 pragma solidity ^0.4.15;

 contract Reentrance {
     mapping (address => uint) userBalance;

     function getBalance(address u) constant returns(uint){
         return userBalance[u];
     }

     function addToBalance() payable{
         userBalance[msg.sender] += msg.value;
     }

     function withdrawBalance(){
         // send userBalance[msg.sender] ethers to msg.sender
         // if mgs.sender is a contract, it will call its fallback function
         // <yes> <report> REENTRANCY
         if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){
             throw;
         }
         userBalance[msg.sender] = 0;
     }
 }

SOLIDITY_SOURCE_END


=== MODEL_OUTPUT ===
0. The contract uses call.value() in the withdrawBalance() function which can potentially lead to reentrancy attacks. Specifically, line 24 where the external call is made before resetting the balance. This order of operations allows an attacker to call withdrawBalance(), receive funds, and then recursively call withdrawBalance() again before the balance is reset. The lack of proper access control exacerbates this issue as anyone can call withdrawBalance(). The vulnerability is related to both reentrancy and access control categories.

=== ERROR ===


=== ELAPSED_S ===
2.6992
